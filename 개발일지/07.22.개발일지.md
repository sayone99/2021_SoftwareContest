# SSWU Software Contest
## 07.22.개발일지 

### 1. 람다식

**다시 복습해야 할 부분** 

![image](https://user-images.githubusercontent.com/65717358/126583896-f0af9ac3-481a-448e-97e0-366e96f736a7.png)

### 2. 조건문과 반복문

### 2.1. if문
![image](https://user-images.githubusercontent.com/65717358/126584447-de57634c-86ba-40b8-9e75-b3f4137664cd.png)

### 2.2. when문 
![image](https://user-images.githubusercontent.com/65717358/126584549-605a211b-6c66-4496-aa5b-22e12110dea2.png)

- 자바의 switch문을 대체한 것으로, when 변수가 x값일 때~~ 어떻게 할 지 설정한다. 


1) 일반적인 케이스 분류 
![image](https://user-images.githubusercontent.com/65717358/126584825-3de62a73-5772-4156-84d6-fce04e0bd733.png)

- max 변수가 10일때, 20일때, 그 외일 때 해당하는 명령을 실행한다. 

2) 두 가지의 경우가 함께 나타날 때 
![image](https://user-images.githubusercontent.com/65717358/126584862-f86f7656-6d75-48fc-b9fb-89ccf3520c5d.png)

- max 변수가 10이나 20이일때, 그 외일 때 해당하는 명령을 실행한다. 

3) 범위에 해당할 때
![image](https://user-images.githubusercontent.com/65717358/126584888-32913d15-4445-4689-bbbc-3998fc6212e9.png)

- `in` 키워드를 사용하여 범위에 속함을 표현할 수 있으며 `..`으로 범위를 표현할 수 있다. 
- `10..20` : 10 ~ 20 사이 `in 10..20` : 10에서 20 사이에 있을 때  


### 2.3. for문 

- for문은 특히 in과 함께 자주 쓰인다. 

1) 범위 안에 들어가는 경우 모두 반복 

*EX.* 

![image](https://user-images.githubusercontent.com/65717358/126585125-4ea8f139-3023-48e5-8a45-c67511ebf028.png)
 
2) 범위를 역순으로, 몇칸씩 건너뛰며 반복

*EX.* 

![image](https://user-images.githubusercontent.com/65717358/126585158-0271036b-6b3a-4912-bd01-31016d1f0152.png)

3) 어떤 범위까지 반복 

*EX.* 

![image](https://user-images.githubusercontent.com/65717358/126585189-3fb1fad7-804c-4b7a-9763-8a2878b4e37f.png)
 
### 3. 클래스와 상속
### 3.1. 클래스 

- 클래스는 객체지향 프로그래밍 언어에서 자주 사용되는 개념이다. ((클래스나 상속을 이용하여 앱 화면에 구현하는 것이 굉장히 흥미롭다고 한다! 어려운 개념이지만 열심히 배워보자)) 

- 클래스는 붕어빵 틀과 같은 개념. 붕어빵을 만들어낼때 반죽을 하나하나 빚는 다면 시간이 오래걸리겠지만 틀에 넣어 만들면 속도가 굉장히 빨라진다. 여기서 만들어진 붕어빵이 바로 객체(인스턴스 객체)이다. 

- 다르게 생각하면 클래스는 grouping 하는, group 개념이 될 수 있다. a이름의 사람, b이름의 사람, c이름의 사람이라는 객체가 모두 "사람"을 만드는 클래스 하나에서 생성된 객체들이기 때문이다. 그렇기에 그 객체들을 하나로 묶을 수 있는(grouping) 기준 또한 클래스가 될 수 있다는 것. 


![image](https://user-images.githubusercontent.com/65717358/126586504-974cc45f-5189-4b91-8709-3ce4082d162c.png)

- 새롭게 패키지를 생성해보면서 클래스의 개념을 익힐 수 있다. Calc1이라는 package를 생성하면 `class Calc {}`라는 클래스가 생성된 것을 볼 수 있다. `class` 키워드 뒤에 그 클래스의 이름이 붙고 {} 중괄호 안에 함수와 변수가 들어가게 된다. 

- 위의 이미지를 통해 계산기 클래스가 만들어진 것을 알 수 있다. 이는 즉, "MainActivity.kt"에서 계산기 객체를 생성할 수 있음을 의미한다. 

- 만약 클래스 이름과 그 뒤에 () 소괄호를 붙이면 (함수처럼) 클래스에서 객체가 하나 생성되는 것이다. 붕어빵이 하나 만들어지는 것! 

- 변수를 생성하여 할당하면 변수상자가 클래스가 만든 객체를 가리키고 있는 것이 된다. 

- **붕어빵틀, 즉 "클래스"는 변수상자의 자료형이 될 수 있다. 클래스 모양대로 객체가 만들어지기 때문.** 
```var calc1:Calc = Calc()``` --> Calc() 클래스가 만든 객체는 calc1이고 이 객체의 자료형은 Calc 클래스이다. 

### 3.2. 개체의 속성 접근

- 클래스를 만들 때 클래스 안에 정의한 속성을 객체 또한 똑같이 그 속성에 접근하고 그것을 생성할 수 있다. 

![image](https://user-images.githubusercontent.com/65717358/126596218-285145f6-1f77-49fb-b55b-9e49da16628a.png)

--> Calc 클래스를 만들었고 클래스 안에 name이라는 변수를 만들었기 때문에 (클래스 안에 변수를 만들면 이는 '속성'이라고 칭함) 객체 calc1에서도 그 속성인 name에 접근하여 ```calc1.name = "철수"```를 할 수 있다.  

- 개체는 클래스 안에 만들어진 함수에도 접근할 수 있다. 
![image](https://user-images.githubusercontent.com/65717358/126596475-b3a43294-e83a-451d-a140-2701590dd9c6.png)
 
---
**고민할 점**
1. 메서드를 호출한다는데, 메서드가 클래스 안에 만든 함수를 말하는 건가? 변수가 클래스 안에 만들어지면 속성이라고 부르듯이 함수가 클래스 안에 만들어지면 메서드라고 불리는 것? 
---

--- 
**반드시 꼭 다시 복습할 것!**
![image](https://user-images.githubusercontent.com/65717358/126588436-b8e36495-1a55-4f77-afcd-f18bdc983ac2.png)

 1) 16번째 줄 ~ 19번째 줄 
    - calc 클래스가 만들어졌기 때문에 ```val calc1 = Calc()``` 으로 클래스 객체 calc1을 생성했다. 
    - ```calc1.name = name```으로 Calc 클래스 안의 name 변수에 접근할 수 있다. 
    - show 함수의 소괄호안에서 변수를 사용하려면 $와 함께 쓰는데, 코드로 작성했기 때문에 {} 중괄호를 함께 쓰는 것이 좋다. 
----


### 3.3. 인스턴스(객체)가 만들어질 때 기능 수행하기 

1) 

![image](https://user-images.githubusercontent.com/65717358/126596873-b6199c09-d953-4f99-a0c9-5d9c20d6ad91.png)

- 클래스 안에 변수 상자를 만들면 반드시 초기값을 설정해야 한다. 이 때 초기값은 null로 설정가능하다. 
- 위 이미지에서는 문자열, 정수형의 변수상자를 확인할 수 있다. 또한, ```lateinit var```로 초기값을 나중에 설정한다는 변수도 볼 수 있다. 

![image](https://user-images.githubusercontent.com/65717358/126597849-61c6a71c-b299-491a-ad14-664a6242d3db.png)

- 객체가 만들어지면 클래스가 함수처럼 호출되기 때문에 사실상 함수가 호출되듯이 {} 중괄호 안에 있는 코드들이 실행되는 것과 동일하다. 그리고 그 안의 코드들을 "기본 생성자"라고 한다. 개체가 만들어지면 클래스에 만들어 놓은 코드들이 기본적으로 생성된다는 의미이다. 만약 그 기본 생성자 안에서 다른 코드를 실행하고 싶다면 ```init```이라는 코드블럭을 사용한다. 
- Person 클래스로 개체가 만들어질 때 콘솔창에 ```println("생성자가 호출됨")``` 코드블럭이 실행된다. 즉, 기본 생성자가 실행되면서 init 코드블럭도 함께 실행된다. 
- 개체를 만들때 함수처럼 () 소괄호를 사용하는데 이 역시 파라미터를 넣어 기본 생성자에 전달할 수 있다. 

![image](https://user-images.githubusercontent.com/65717358/126599846-c23682f2-f2d7-4a66-aa68-61f17e4a3944.png)



---
**고민할 점**
1. 파라미터를 넣는다는 것이 정확히 잘 이해되지 않음.. (chapter4의 2번째 강의.. 잘 이해되지 않음..) 
2. 기본 생성자라는 것이 정확히 무엇일까..? 변수를 의미...? 기본 생성자와 construtor(), init 코드블럭은 다르게 구분하는 것 같던데 그 구분 기준을 잘 모르겠음. 
---

### 3.4. 생성자 함수 

- 기본 생성자외에 생성자를 만들고 싶다면 `constructor()` 함수를 이용해서 만들 수 있다. 

1) 생성자 함수1 - 생성자 함수 만들어보기

- ![image](https://user-images.githubusercontent.com/65717358/126631948-7f654bcd-5b7c-442c-b273-560a5b328702.png)
 
 ```this.name = name``` 이라는 코드 블럭의 의미를 잘 해석해보면 클래스의 속성, 생성자 함수와의 관계를 잘 이해할 수 있다. 
 
 ![image](https://user-images.githubusercontent.com/65717358/126632155-e4ddc565-5b49-4411-a869-808da3be0b43.png)
 
 두번째 생성자 함수는 null 값을 받을 수 있도록 nullable type으로 자료형을 설정할 수도 있다. 이는 전제조건이 필요한데 바로 5번째 줄에서 ```var name:String? = null```로 name에 nullable 값도 가능하다는 것이다. 
 
2) 생성자 함수2 - 객체를 생성하고 그 객체에 생성자 함수 적용해보기 
 
 1) ![image](https://user-images.githubusercontent.com/65717358/126632825-00cd34b1-6cbe-4593-ba34-ff2c094fd6b2.png)
 2) ![image](https://user-images.githubusercontent.com/65717358/126632854-ae2bd4ef-3ecf-48b7-872c-8244d70ef712.png)
  
 - 위의 이미지를 보면 1번째 이미지에서 세번째 생성자를 생성하고 3개의 파라미터 구멍을 만들었기 때문에 
   2번째 이미지에서 처럼 각각 인수를 입력해 객체를 생성할 수 있다. 

3) 생성자 함수 정리 

![image](https://user-images.githubusercontent.com/65717358/126633295-da238119-afc7-4913-be93-d9c811e78f91.png)

- 반환하는 것은 없으며 파라미터가 다양한 형태로 만들어질 수 있음. 

4) 생성자 함수3 

---
**참고**

![image](https://user-images.githubusercontent.com/65717358/126633519-b3f415e4-ff69-4ead-9bf0-619426caa26b.png)

- 여기서 파라미터에 직접 넣은 ```var name:String?```은 곧 {}중괄호 안에 들어있는 기본 생성자랑 같다고 생각하면 된다. 즉 {} 중괄호 안에 똑같이 들어있는 것이다. 

---

---
**고민할 점**
1. 

![image](https://user-images.githubusercontent.com/65717358/126634382-228ae163-d427-49d2-963c-e6b485dc84bd.png)

- 여기서 기본 생성자 name이 있는 상태에서 또 다시 constructor() 생성자 함수로 name 똑같은 걸 만드려고 해서 문제가 생겼던 건지
궁금하다. 기본 생성자가 있기 때문에 뒤에 `:this(name)`이라고 붙였는데 그 이유를 제대로 이해하기 힘들었음. 
기본 생성자, 생성자 함수간의 이해가 좀 더 필요한듯. 
---
